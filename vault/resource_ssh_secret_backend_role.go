package vault

import (
	"fmt"
	"log"
	"strings"

	"github.com/hashicorp/terraform/helper/schema"
	"github.com/hashicorp/vault/api"
	"net"
	"regexp"
)

var (
	sshSecretBackendKeyTypeOTP     = "otp"
	sshSecretBackendKeyTypeDynamic = "dynamic"
	sshSecretBackendKeyTypeCA      = "ca"
	sshSecretBackendRolePathRegex  = regexp.MustCompile("^(.+)/role/(.+)$")
)

func sshSecretBackendRoleResource() *schema.Resource {
	return &schema.Resource{
		Create: sshSecretBackendRoleCreate,
		Read:   sshSecretBackendRoleRead,
		Update: sshSecretBackendRoleUpdate,
		Delete: sshSecretBackendRoleDelete,
		Exists: sshSecretBackendRoleExists,
		Importer: &schema.ResourceImporter{
			State: schema.ImportStatePassthrough,
		},

		Schema: map[string]*schema.Schema{
			"role": {
				Type:        schema.TypeString,
				Required:    true,
				Description: "Name of the role.",
				ForceNew:    true,
			},
			"key_type": {
				Type:        schema.TypeString,
				Required:    true,
				Description: "Type of credentials generated by this role. This can be either otp, dynamic or ca.",
				ForceNew:    true,
				ValidateFunc: func(v interface{}, k string) (ws []string, errs []error) {
					value := v.(string)
					if value != sshSecretBackendKeyTypeOTP && value != sshSecretBackendKeyTypeDynamic && value != sshSecretBackendKeyTypeCA {
						errs = append(errs, fmt.Errorf("key_type must be otp, dynamic or ca"))
					}
					return
				},
			},
			"key": {
				Type:        schema.TypeString,
				Optional:    true,
				Description: "Name of the registered key in Vault. Before creating the role, use the keys/ endpoint to create a named key.",
				ForceNew:    true,
			},
			"admin_user": {
				Type:        schema.TypeString,
				Optional:    true,
				Description: "Admin user at remote host. The shared key being registered should be for this user and should have root or sudo privileges. Every time a dynamic credential is generated for a client, Vault uses this admin username to login to remote host and install the generated credential.",
			},
			"default_user": {
				Type:        schema.TypeString,
				Optional:    true,
				Description: "Default username for which a credential will be generated. When the endpoint creds/ is used without a username, this value will be used as default username. Its recommended to create individual roles for each username to ensure absolute isolation between usernames.",
			},
			"cidr_list": {
				Type:        schema.TypeList,
				Optional:    true,
				Description: "CIDR blocks for which the role is applicable for. It is possible that a same set of CIDR blocks are part of multiple roles.",
				Elem: &schema.Schema{
					Type: schema.TypeString,
					ValidateFunc: func(v interface{}, k string) (ws []string, errs []error) {
						value := v.(string)
						if _, _, err := net.ParseCIDR(value); err != nil {
							errs = append(errs, fmt.Errorf("invalid CIDR %s for cidr_list", value))
						}
						return
					},
				},
			},
			"exclude_cidr_list": {
				Type:        schema.TypeList,
				Optional:    true,
				Description: "IP addresses belonging to these blocks are not accepted by the role. This is particularly useful when big CIDR blocks are being used by the role and certain parts need to be kept out.",
				Elem: &schema.Schema{
					Type: schema.TypeString,
					ValidateFunc: func(v interface{}, k string) (ws []string, errs []error) {
						value := v.(string)
						if _, _, err := net.ParseCIDR(value); err != nil {
							errs = append(errs, fmt.Errorf("invalid CIDR %s for exclude_cidr_list", value))
						}
						return
					},
				},
			},
			"port": {
				Type:        schema.TypeInt,
				Optional:    true,
				Description: "Port number for SSH connection. Port number does not play any role in OTP generation. For the otp secrets engine type, this is just a way to inform the client about the port number to use. The port number will be returned to the client by Vault along with the OTP.",
			},
			"key_bits": {
				Type:        schema.TypeInt,
				Optional:    true,
				Default:     1024,
				Description: "Length of the RSA dynamic key in bits.",
				ValidateFunc: func(v interface{}, k string) (ws []string, errs []error) {
					value := v.(int)
					if value != 1024 && value != 2048 {
						errs = append(errs, fmt.Errorf("key_bits must be 1024 or 2048"))
					}
					return
				},
			},
			"install_script": {
				Type:        schema.TypeString,
				Optional:    true,
				Description: "Script used to install and uninstall public keys in the target machine. Defaults to the built-in script.",
			},
			"allowed_users": {
				Type:        schema.TypeList,
				Optional:    true,
				Description: "If this option is not specified, or if it is *, the client can request a credential for any valid user at the remote host, including the admin user. If only certain usernames are to be allowed, then this list enforces it. If this field is set, then credentials can only be created for default_user and usernames present in this list. Setting this option will enable all the users with access this role to fetch credentials for all other user names in this list. Use with caution. N.B.: if the type is ca, an empty list does not allow any user; instead you must use * to enable this behavior.",
				Elem: &schema.Schema{
					Type: schema.TypeString,
				},
			},
			"allowed_domains": {
				Type:        schema.TypeList,
				Optional:    true,
				Description: "List of domains for which a client can request a host certificate. If this option is explicitly set to *, then credentials can be created for any domain. See also allow_bare_domains and allow_subdomains.",
				Elem: &schema.Schema{
					Type: schema.TypeString,
				},
			},
			"key_option_specs": {
				Type:        schema.TypeList,
				Optional:    true,
				Description: "Option specification which will be prefixed to RSA keys in the remote host's authorized_keys file. N.B.: Vault does not check this string for validity.",
				Elem: &schema.Schema{
					Type: schema.TypeString,
				},
			},
			"ttl": {
				Type:        schema.TypeString,
				Optional:    true,
				Description: "TTL value provided as a string duration with time suffix. Hour is the largest suffix. If not set, uses the system default value or the value of max_ttl, whichever is shorter.",
			},
			"max_ttl": {
				Type:        schema.TypeString,
				Optional:    true,
				Description: "Mmaximum TTL provided as a string duration with time suffix. Hour is the largest suffix. If not set, defaults to the system maximum lease TTL.",
			},
			"allowed_critical_options": {
				Type:        schema.TypeList,
				Optional:    true,
				Description: "List of critical options that certificates can have when signed. To allow any critical options, set this to an empty list. Will default to allowing any critical options.",
				Elem: &schema.Schema{
					Type: schema.TypeString,
				},
			},
			"allowed_extensions": {
				Type:        schema.TypeList,
				Optional:    true,
				Description: "List of extensions that certificates can have when signed. To allow any critical options, set this to an empty list. Will default to allowing any extensions.",
				Elem: &schema.Schema{
					Type: schema.TypeString,
				},
			},
			"default_critical_options": {
				Type:        schema.TypeMap,
				Optional:    true,
				Description: "Map of critical options certificates should have if none are provided when signing. Note that these are not restricted by allowed_critical_options. Defaults to none.",
				Elem: &schema.Schema{
					Type: schema.TypeString,
				},
			},
			"default_extensions": {
				Type:        schema.TypeMap,
				Optional:    true,
				Description: "Map of extensions certificates should have if none are provided when signing. Note that these are not restricted by allowed_extensions. Defaults to none.",
				Elem: &schema.Schema{
					Type: schema.TypeString,
				},
			},
			"allow_user_certificates": {
				Type:        schema.TypeBool,
				Optional:    true,
				Description: "Specifies if certificates are allowed to be signed for use as a 'user'.",
			},
			"allow_host_certificates": {
				Type:        schema.TypeBool,
				Optional:    true,
				Description: "Specifies if certificates are allowed to be signed for use as a 'host'.",
			},
			"allow_bare_domains": {
				Type:        schema.TypeBool,
				Optional:    true,
				Description: "Specifies if host certificates that are requested are allowed to use the base domains listed in allowed_domains, e.g. 'example.com'. This is a separate option as in some cases this can be considered a security threat.",
			},
			"allow_subdomains": {
				Type:        schema.TypeBool,
				Optional:    true,
				Description: "Specifies if host certificates that are requested are allowed to be subdomains of those listed in allowed_domains, e.g. if 'example.com' is part of allowed_domains, this allows 'foo.example.com'",
			},
			"allow_user_key_ids": {
				Type:        schema.TypeBool,
				Optional:    true,
				Description: "Specifies if users can override the key ID for a signed certificate with the 'key_id' field. When false, the key ID will always be the token display name. The key ID is logged by the SSH server and can be useful for auditing.",
			},
			"key_id_format": {
				Type:        schema.TypeString,
				Optional:    true,
				Description: "When supplied, this value specifies a custom format for the key id of a signed certificate. The following variables are available for use: '{{token_display_name}}' - The display name of the token used to make the request. '{{role_name}}' - The name of the role signing the request. '{{public_key_hash}}' - A SHA256 checksum of the public key that is being signed. e.g. 'custom-keyid-{{token_display_name}}'",
			},
			"backend": {
				Type:        schema.TypeString,
				Optional:    true,
				Description: "Unique name of the auth backend to configure.",
				ForceNew:    true,
				Default:     "ssh",
				// standardise on no beginning or trailing slashes
				StateFunc: func(v interface{}) string {
					return strings.Trim(v.(string), "/")
				},
			},
		},
	}
}

func sshSecretBackendRoleCreate(d *schema.ResourceData, meta interface{}) error {
	client := meta.(*api.Client)

	backend := d.Get("backend").(string)
	role := d.Get("role").(string)
	path := sshSecretBackendRolePath(backend, role)

	log.Printf("[DEBUG] Writing SSH secret backend role %q", path)
	data, err := sshSecretBackendResourceDataToData(d)
	if err != nil {
		return err
	}

	_, err = client.Logical().Write(path, data)
	d.SetId(path)

	if err != nil {
		d.SetId("")
		return fmt.Errorf("Error writing SSH secret backend role %q: %s", path, err)
	}
	log.Printf("[DEBUG] Wrote SSH secret backend role %q", path)

	return sshSecretBackendRoleRead(d, meta)
}

func sshSecretBackendRoleRead(d *schema.ResourceData, meta interface{}) error {
	client := meta.(*api.Client)
	path := d.Id()

	backend, role, err := sshSecretBackendRoleParsePath(path)
	if err != nil {
		return fmt.Errorf("Invalid path %q for SSH secret backend role: %s", path, err)
	}

	log.Printf("[DEBUG] Reading SSH secret backend role %q", path)
	resp, err := client.Logical().Read(path)
	if err != nil {
		return fmt.Errorf("Error reading SSH secret backend role %q: %s", path, err)
	}
	log.Printf("[DEBUG] Read SSH secret backend role %q", path)
	if resp == nil {
		log.Printf("[WARN] SSH secret backend role %q not found, removing from state", path)
		d.SetId("")
		return nil
	}

	d.Set("backend", backend)
	d.Set("role", role)
	d.Set("key_type", resp.Data["key_type"])
	d.Set("key", resp.Data["key"])
	d.Set("admin_user", resp.Data["admin_user"])
	d.Set("default_user", resp.Data["default_user"])
	d.Set("cidr_list", sshSecretBackendStringToList(resp.Data["default_user"]))
	d.Set("exclude_cidr_list", sshSecretBackendStringToList(resp.Data["exclude_cidr_list"]))
	d.Set("port", resp.Data["port"])
	d.Set("key_bits", resp.Data["key_bits"])
	d.Set("install_script", resp.Data["install_script"])
	d.Set("allowed_users", sshSecretBackendStringToList(resp.Data["allowed_users"]))
	d.Set("allowed_domains", sshSecretBackendStringToList(resp.Data["allowed_domains"]))
	d.Set("key_option_specs", sshSecretBackendStringToList(resp.Data["key_option_specs"]))
	d.Set("ttl", resp.Data["ttl"])
	d.Set("max_ttl", resp.Data["max_ttl"])
	d.Set("allowed_critical_options", sshSecretBackendStringToList(resp.Data["allowed_critical_options"]))
	d.Set("allowed_extensions", sshSecretBackendStringToList(resp.Data["allowed_extensions"]))
	d.Set("default_critical_options", resp.Data["default_critical_options"])
	d.Set("default_extensions", resp.Data["default_extensions"])
	d.Set("allow_user_certificates", resp.Data["allow_user_certificates"])
	d.Set("allow_host_certificates", resp.Data["allow_host_certificates"])
	d.Set("allow_bare_domains", resp.Data["allow_bare_domains"])
	d.Set("allow_subdomains", resp.Data["allow_subdomains"])
	d.Set("allow_user_key_ids", resp.Data["allow_user_key_ids"])
	d.Set("key_id_format", resp.Data["key_id_format"])

	return nil
}

func sshSecretBackendRoleUpdate(d *schema.ResourceData, meta interface{}) error {
	client := meta.(*api.Client)
	path := d.Id()

	log.Printf("[DEBUG] Updating SSH secret backend role %q", path)
	data, err := sshSecretBackendResourceDataToData(d)
	if err != nil {
		return err
	}

	_, err = client.Logical().Write(path, data)
	if err != nil {
		return fmt.Errorf("Error updating SSH secret backend role %q: %s", path, err)
	}
	log.Printf("[DEBUG] Updated SSH secret backend role %q", path)

	return sshSecretBackendRoleRead(d, meta)
}

func sshSecretBackendRoleDelete(d *schema.ResourceData, meta interface{}) error {
	client := meta.(*api.Client)
	path := d.Id()

	log.Printf("[DEBUG] Deleting SSH secret backend role %q", path)
	_, err := client.Logical().Delete(path)
	if err != nil {
		return fmt.Errorf("Error deleting SSH secret backend role %q: %s", path, err)
	}
	log.Printf("[DEBUG] Deleted SSH secret backend role %q", path)

	return nil
}

func sshSecretBackendRoleExists(d *schema.ResourceData, meta interface{}) (bool, error) {
	client := meta.(*api.Client)

	path := d.Id()
	log.Printf("[DEBUG] Checking if SSH secret backend role %q exists", path)

	resp, err := client.Logical().Read(path)
	if err != nil {
		return true, fmt.Errorf("Error checking if SSH secret backend role %q exists: %s", path, err)
	}
	log.Printf("[DEBUG] Checked if SSH secret backend role %q exists", path)

	return resp != nil, nil
}

func sshSecretBackendResourceDataToData(d *schema.ResourceData) (map[string]interface{}, error) {
	keyType := d.Get("key_type").(string)
	data := map[string]interface{}{
		"key_type": keyType,
	}
	if v, ok := d.GetOk("default_user"); ok {
		data["default_user"] = v.(string)
	} else if keyType == sshSecretBackendKeyTypeOTP || keyType == sshSecretBackendKeyTypeDynamic {
		return nil, fmt.Errorf("default_user field is required for otp and dynamic key type")
	}
	if v, ok := d.GetOk("allowed_users"); ok {
		data["allowed_users"] = sshSecretBackendListToString(v)
	}

	if keyType == sshSecretBackendKeyTypeDynamic {
		if v, ok := d.GetOk("admin_user"); ok {
			data["admin_user"] = v.(string)
		} else {
			return nil, fmt.Errorf("admin_user field is required for dynamic key type")
		}
		if v, ok := d.GetOk("key"); ok {
			data["key"] = v.(string)
		} else {
			return nil, fmt.Errorf("key field is required for dynamic key type")
		}
		if v, ok := d.GetOk("install_script"); ok {
			data["install_script"] = v.(string)
		}
		if v, ok := d.GetOk("key_bits"); ok {
			data["key_bits"] = v.(int)
		}
		if v, ok := d.GetOk("key_option_specs"); ok {
			data["key_option_specs"] = sshSecretBackendListToString(v)
		}
	}

	if keyType == sshSecretBackendKeyTypeDynamic || keyType == sshSecretBackendKeyTypeOTP {
		if v, ok := d.GetOk("cidr_list"); ok {
			data["cidr_list"] = sshSecretBackendListToString(v)
		}
		if v, ok := d.GetOk("exclude_cidr_list"); ok {
			data["exclude_cidr_list"] = sshSecretBackendListToString(v)
		}
		if v, ok := d.GetOk("port"); ok {
			data["port"] = v.(int)
		}
	}

	if keyType == sshSecretBackendKeyTypeCA {
		if v, ok := d.GetOk("allowed_domains"); ok {
			data["allowed_domains"] = sshSecretBackendListToString(v)
		}
		if v, ok := d.GetOk("ttl"); ok {
			data["ttl"] = v.(string)
		}
		if v, ok := d.GetOk("max_ttl"); ok {
			data["max_ttl"] = v.(string)
		}
		if v, ok := d.GetOk("allowed_critical_options"); ok {
			data["allowed_critical_options"] = sshSecretBackendListToString(v)
		}
		if v, ok := d.GetOk("allowed_extensions"); ok {
			data["allowed_extensions"] = sshSecretBackendListToString(v)
		}
		if v, ok := d.GetOk("default_critical_options"); ok {
			data["default_critical_options"] = v.(map[string]string)
		}
		if v, ok := d.GetOk("default_extensions"); ok {
			data["default_extensions"] = v.(map[string]string)
		}
		if v, ok := d.GetOk("allow_user_certificates"); ok {
			data["allow_user_certificates"] = v.(bool)
		}
		if v, ok := d.GetOk("allow_host_certificates"); ok {
			data["allow_host_certificates"] = v.(bool)
		}
		if v, ok := d.GetOk("allow_bare_domains"); ok {
			data["allow_bare_domains"] = v.(bool)
		}
		if v, ok := d.GetOk("allow_subdomains"); ok {
			data["allow_subdomains"] = v.(bool)
		}
		if v, ok := d.GetOk("allow_user_key_ids"); ok {
			data["allow_user_key_ids"] = v.(bool)
		}
		if v, ok := d.GetOk("key_id_format"); ok {
			data["key_id_format"] = v.(string)
		}
	}

	return data, nil
}

func sshSecretBackendListToString(data interface{}) string {
	iList := data.([]interface{})
	list := make([]string, len(iList))
	for index, value := range iList {
		list[index] = value.(string)
	}

	return strings.Join(list, ",")
}

func sshSecretBackendStringToList(data interface{}) []string {
	str := data.(string)
	if str == "" {
		return []string{}
	}

	return strings.Split(data.(string), ",")
}

func sshSecretBackendRolePath(backend, role string) string {
	return strings.Trim(backend, "/") + "/role/" + strings.Trim(role, "/")
}

func sshSecretBackendRoleParsePath(path string) (string, string, error) {
	if !sshSecretBackendRolePathRegex.MatchString(path) {
		return "", "", fmt.Errorf("invalid path for ssh secret backend role")
	}
	res := sshSecretBackendRolePathRegex.FindStringSubmatch(path)
	if len(res) != 3 {
		return "", "", fmt.Errorf("unexpected number of matches (%d) for ssh secret backend role", len(res))
	}
	return res[1], res[2], nil
}
